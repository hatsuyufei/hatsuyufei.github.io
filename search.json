[{"title":"SpringBoot通用工具合集","url":"//posts/271221202051072.html","content":"通用工具大合集\r\n每次做后端项目的时候有很多东西要添加，但我没有做一个一键生成的工具来进行，这里我把一些基础的工具的封装类放到下面来，以后想加什么就可以直接通过这个帖子往下一个个添加即可，争取这些工具配置不冲突如果冲突会说明。\r\n纯工具\r\n统一返回\r\n很关键的一个地方，这个统一返回类可以拦截除了过滤器添加所有异常，无论你使用的是throw new BueinessException或者说是return BueinessErrorResponseVO\r\n都可以拦截，只会给前端一个友好的提示，这个很关键!\r\n目录树\r\n- controller - ABaseController.java- entity - enums  - ResponseCodeEnum.enum - vo  - ResponseVO.java- exception - BusinessException.java\r\n相关依赖 - 无\r\n相关配置 - 无\r\n代码相关\r\nABaseController\r\npackage com.redisdemo.controller;import com.redisdemo.entity.enums.ResponseCodeEnum;import com.redisdemo.entity.vo.ResponseVO;import com.redisdemo.exception.BusinessException;public class ABaseController &#123;    protected static final String STATUC_SUCCESS = &quot;success&quot;;    protected static final String STATUC_ERROR = &quot;error&quot;;    protected &lt;T&gt; ResponseVO getSuccessResponseVO(T t) &#123;        ResponseVO&lt;T&gt; responseVO = new ResponseVO&lt;&gt;();        responseVO.setStatus(STATUC_SUCCESS);        responseVO.setCode(ResponseCodeEnum.CODE_200.getCode());        responseVO.setInfo(ResponseCodeEnum.CODE_200.getMsg());        responseVO.setData(t);        return responseVO;    &#125;    protected &lt;T&gt; ResponseVO getBusinessErrorResponseVO(BusinessException e, T t) &#123;        ResponseVO vo = new ResponseVO();        vo.setStatus(STATUC_ERROR);        if (e.getCode() == null) &#123;            vo.setCode(ResponseCodeEnum.CODE_600.getCode());        &#125; else &#123;            vo.setCode(e.getCode());        &#125;        vo.setInfo(e.getMessage());        vo.setData(t);        return vo;    &#125;    protected &lt;T&gt; ResponseVO getServerErrorResponseVO(T t) &#123;        ResponseVO vo = new ResponseVO();        vo.setStatus(STATUC_ERROR);        vo.setCode(ResponseCodeEnum.CODE_500.getCode());        vo.setInfo(ResponseCodeEnum.CODE_500.getMsg());        vo.setData(t);        return vo;    &#125;&#125;\r\nResponseCodeEnum\r\npackage com.redisdemo.entity.enums;public enum ResponseCodeEnum &#123;    CODE_200(200, &quot;请求成功&quot;),    CODE_404(404, &quot;请求地址不存在&quot;),    CODE_600(600, &quot;请求参数错误&quot;),    CODE_601(601, &quot;信息已经存在&quot;),    CODE_901(901, &quot;登录超时&quot;),    CODE_500(500, &quot;服务器返回错误，请联系管理员&quot;);    private Integer code;    private String msg;    ResponseCodeEnum(Integer code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;    public Integer getCode() &#123;        return code;    &#125;    public String getMsg() &#123;        return msg;    &#125;&#125;\r\nResponseVO\r\npackage com.redisdemo.entity.vo;public class ResponseVO&lt;T&gt; &#123;    private String status;    private Integer code;    private String info;    private T data;    public String getStatus() &#123;        return status;    &#125;    public void setStatus(String status) &#123;        this.status = status;    &#125;    public Integer getCode() &#123;        return code;    &#125;    public void setCode(Integer code) &#123;        this.code = code;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    public String getInfo() &#123;        return info;    &#125;    public void setInfo(String info) &#123;        this.info = info;    &#125;&#125;\r\nBusinessException\r\npackage com.redisdemo.exception;import com.redisdemo.entity.enums.ResponseCodeEnum;public class BusinessException extends RuntimeException &#123;    private ResponseCodeEnum codeEnum;    private Integer code;    private String message;    public BusinessException(String message, Throwable e) &#123;        super(message, e);        this.message = message;    &#125;    public BusinessException(String message) &#123;        super(message);        this.message = message;    &#125;    public BusinessException(Throwable e) &#123;        super(e);    &#125;    public BusinessException(ResponseCodeEnum codeEnum) &#123;        super(codeEnum.getMsg());        this.codeEnum = codeEnum;        this.code = codeEnum.getCode();        this.message = codeEnum.getMsg();    &#125;    public BusinessException(Integer code, String message) &#123;        super(message);        this.code = code;        this.message = message;    &#125;    public ResponseCodeEnum getCodeEnum() &#123;        return codeEnum;    &#125;    public Integer getCode() &#123;        return code;    &#125;    @Override    public String getMessage() &#123;        return message;    &#125;    /**     * 重写fillInStackTrace 业务异常不需要堆栈信息，提高效率.目的是为了看到错误而不是看哪行抛出，抛出位置不一定是错误位置     */    @Override    public Throwable fillInStackTrace() &#123;        return this;    &#125;&#125;\r\n用户Id随机算法\r\n目录树\r\n- utils - IdGeneratorUtil.java\r\n相关依赖 - 无\r\n相关配置 - 无\r\n代码相关\r\nIdGeneratorUtil\r\npackage com.redisdemo.util;import org.springframework.stereotype.Component;/** * 极简雪花算法ID生成器 */@Componentpublic class IdGeneratorUtil &#123;    // 开始时间戳 (2024-01-01)    private static final long START_TIMESTAMP = 1704067200000L;    // 上次生成ID的时间戳    private long lastTimestamp = -1L;    // 序列号    private long sequence = 0L;    // 序列号位数    private static final long SEQUENCE_BITS = 12L;    // 序列号最大值    private static final long MAX_SEQUENCE = ~(-1L &lt;&lt; SEQUENCE_BITS);    // 锁对象    private final Object lock = new Object();    /**     * 生成唯一ID     */    public long nextId() &#123;        synchronized (lock) &#123;            long timestamp = System.currentTimeMillis();            // 时钟回拨处理            if (timestamp &lt; lastTimestamp) &#123;                throw new RuntimeException(&quot;时钟回拨异常&quot;);            &#125;            // 同一毫秒内生成            if (lastTimestamp == timestamp) &#123;                sequence = (sequence + 1) &amp; MAX_SEQUENCE;                if (sequence == 0) &#123;                    // 序列号用完，等待下一毫秒                    timestamp = tilNextMillis(lastTimestamp);                &#125;            &#125; else &#123;                sequence = 0L;            &#125;            lastTimestamp = timestamp;            // 组合ID            return ((timestamp - START_TIMESTAMP) &lt;&lt; SEQUENCE_BITS) | sequence;        &#125;    &#125;    /**     * 生成字符串ID     */    public String nextIdStr() &#123;        return String.valueOf(nextId());    &#125;    /**     * 阻塞到下一毫秒     */    private long tilNextMillis(long lastTimestamp) &#123;        long timestamp = System.currentTimeMillis();        while (timestamp &lt;= lastTimestamp) &#123;            timestamp = System.currentTimeMillis();        &#125;        return timestamp;    &#125;&#125;\r\nSpringSecurity相关\r\n用户密码加密\r\n目录树\r\n- utils - PasswordEncryptUtil.java\r\n相关依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;    &lt;artifactId&gt;spring-security-crypto&lt;/artifactId&gt;&lt;/dependency&gt;\r\n相关配置 - 无\r\n代码相关\r\nPasswordEncryptUtil\r\npackage com.redisdemo.util;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;@Componentpublic class PasswordEncryptUtil &#123;    private static final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();    /**     * 加密密码     * @param rawPassword 明文密码     * @return 加密后的密码     */    public static String encryptPassword(String rawPassword) &#123;        if (rawPassword == null) &#123;            throw new IllegalArgumentException(&quot;密码不能为null&quot;);        &#125;        return passwordEncoder.encode(rawPassword);    &#125;    /**     * 验证密码     * @param rawPassword 明文密码     * @param encodedPassword 加密后的密码     * @return 验证结果     */    public static boolean verifyPassword(String rawPassword, String encodedPassword) &#123;        if (rawPassword == null || encodedPassword == null) &#123;            return false;        &#125;        return passwordEncoder.matches(rawPassword, encodedPassword);    &#125;    /**     * 检查编码后的密码是否需要重新编码（例如，由于算法强度变化）     * @param encodedPassword 已编码的密码     * @return 是否需要重新编码     */    public static boolean isPasswordRehashNeeded(String encodedPassword) &#123;        return passwordEncoder.upgradeEncoding(encodedPassword);    &#125;&#125;\r\nMybatisPlus相关\r\n自动更新时间\r\n目录树\r\n- utils - MyMetaObjectHandler.java\r\n相关依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.5&lt;/version&gt;&lt;/dependency&gt;\r\n相关配置1\r\npackage com.demo;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan(&quot;com.demo.mapper&quot;) //必须注入，然后才能使用public class DemoApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DemoApplication.class, args);    &#125;&#125;\r\n相关配置2\r\n必须在你想要自动更新的地方添加@TableField\r\npackage com.redisdemo.entity.po;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.annotation.TableField;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.time.LocalDateTime;@Entity@Table(name = &quot;user&quot;)public class User &#123;    @Id    private Long id;    private String name;    private String password;    @TableField(fill = FieldFill.INSERT) //很关键    private LocalDateTime createTime;    @TableField(fill = FieldFill.INSERT_UPDATE) //很关键    private LocalDateTime updateTime;&#125;\r\nRedis相关\r\nid-token的加密解密\r\n目录树\r\n- config - RedisConfig- utils - JwtUtil - RedisUtil\r\n相关依赖\r\n&lt;!-- JWT核心依赖 - 基于Sprintboot 2.x --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- JWT核心依赖 - 基于Sprintboot 3.x --&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-api&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-impl-jakarta&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;    &lt;artifactId&gt;jjwt-jackson-jakarta&lt;/artifactId&gt;    &lt;version&gt;0.11.5&lt;/version&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- Spring Boot整合Redis（Lettuce客户端，官方推荐，替代Jedis，自动配置RedisTemplate） --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 连接池（Lettuce默认无连接池，必加！提升Redis性能，否则单连接易瓶颈） --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- lombok - 简化 RedisUtil/JwtUtil 的代码 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;!--fastjson2 - 若 Redis 存储对象时需要高效序列化 / 反序列化--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;    &lt;artifactId&gt;fastjson2&lt;/artifactId&gt;    &lt;version&gt;2.0.32&lt;/version&gt;&lt;/dependency&gt;\r\n相关配置\r\n# ===================== Redis配置 =====================# redis服务地址spring.data.redis.host=localhost# redis服务端口spring.data.redis.port=6379# redis连接密码（无密码留空）spring.data.redis.password=# 操作的redis数据库索引（默认0库）spring.data.redis.database=0# redis连接超时时间spring.data.redis.timeout=2000ms# lettuce连接池配置（springboot2.x默认redis客户端）# 连接池最大活跃连接数spring.data.redis.lettuce.pool.max-active=8# 连接池最大空闲连接数spring.data.redis.lettuce.pool.max-idle=8# 连接池最小空闲连接数spring.data.redis.lettuce.pool.min-idle=0# 连接池最大等待时间（-1表示无限制）spring.data.redis.lettuce.pool.max-wait=-1ms# ===================== JWT令牌配置 =====================# JWT加密密钥（要求至少32位，保证安全性）jwt.secret=my-secret-key-needs-to-be-at-least-32-chars-long-for-security# JWT令牌过期时间（秒），7200秒=2小时jwt.expiration=7200# 前端请求头中携带JWT的名称jwt.header=Authorization# JWT令牌的前缀（前端拼接在令牌前，后端解析时会去掉）jwt.prefix=Bearer \r\n代码相关\r\nRedisConfig\r\npackage com.redisdemo.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory);        // 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        ObjectMapper om = new ObjectMapper();        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(om);        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        // 使用StringRedisSerializer来序列化和反序列化redis的key值        template.setKeySerializer(stringRedisSerializer);        template.setHashKeySerializer(stringRedisSerializer);        // 使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值        template.setValueSerializer(jackson2JsonRedisSerializer);        template.setHashValueSerializer(jackson2JsonRedisSerializer);        template.afterPropertiesSet();        return template;    &#125;    @Bean    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory factory) &#123;        return new StringRedisTemplate(factory);    &#125;&#125;\r\nJwtUtil\r\npackage com.redisdemo.util;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;import java.util.Date;/** * 简化版JWT工具类 - 只支持ID与Token的双向转换 */@Componentpublic class JwtUtil &#123;    // 从配置文件中读取密钥    @Value(&quot;$&#123;jwt.secret:my-secret-key-needs-to-be-at-least-32-chars-long-for-security&#125;&quot;)    private String secret;    // 从配置文件中读取过期时间    @Value(&quot;$&#123;jwt.expiration:7200&#125;&quot;)    private Long expiration; // 默认2小时    /**     * 根据用户ID生成Token     *      * @param userId 用户ID     * @return JWT token     */    public String generateTokenById(Long userId) &#123;        Date now = new Date();        Date expirationDate = new Date(now.getTime() + expiration * 1000);        return Jwts.builder()                .claim(&quot;userId&quot;, userId)                .setIssuedAt(now)                .setExpiration(expirationDate)                .signWith(getSecretKey(), SignatureAlgorithm.HS512)                .compact();    &#125;    /**     * 从Token中解析用户ID          * @param token JWT token     * @return 用户ID     */    public Long getUserIdFromToken(String token) &#123;        Claims claims = getClaimsFromToken(token);        Object userIdObj = claims.get(&quot;userId&quot;);        if (userIdObj instanceof Integer) &#123;            return ((Integer) userIdObj).longValue();        &#125; else if (userIdObj instanceof Long) &#123;            return (Long) userIdObj;        &#125;        return null;    &#125;    /**     * 从token中获取所有声明     *     * @param token JWT token     * @return 声明     */    private Claims getClaimsFromToken(String token) &#123;        return Jwts.parser()                .verifyWith(getSecretKey())                .build()                .parseSignedClaims(token)                .getPayload();    &#125;        private javax.crypto.SecretKey getSecretKey() &#123;        // 确保密钥长度足够支持HS512算法（至少512位/64字节）        byte[] keyBytes = secret.getBytes();                // 如果原始密钥长度不足，通过哈希扩展        if (keyBytes.length &lt; 64) &#123;            try &#123;                java.security.MessageDigest digest = java.security.MessageDigest.getInstance(&quot;SHA-512&quot;);                // 多次哈希确保足够的熵                for (int i = 0; i &lt; 1000; i++) &#123;                    keyBytes = digest.digest(keyBytes);                &#125;            &#125; catch (java.security.NoSuchAlgorithmException e) &#123;                throw new RuntimeException(&quot;获取密钥失败&quot;, e);            &#125;        &#125;                return new javax.crypto.spec.SecretKeySpec(keyBytes, &quot;HmacSHA512&quot;);    &#125;&#125;\r\nRedisUtil\r\npackage com.redisdemo.util;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import org.springframework.util.CollectionUtils;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;/** * Redis操作工具类 */@Componentpublic class RedisUtil &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Autowired    private StringRedisTemplate stringRedisTemplate;    // =============================common============================    /**     * 指定缓存失效时间     * @param key 键     * @param time 时间(秒)     */    public boolean expire(String key, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.expire(key, time, TimeUnit.SECONDS);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 根据key 获取过期时间     * @param key 键 不能为null     * @return 时间(秒) 返回0代表为永久有效     */    public long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    /**     * 判断key是否存在     * @param key 键     * @return true 存在 false不存在     */    public boolean hasKey(String key) &#123;        try &#123;            return redisTemplate.hasKey(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 删除缓存     * @param key 可以传一个值 或多个     */    public void del(String... key) &#123;        if (key != null &amp;&amp; key.length &gt; 0) &#123;            if (key.length == 1) &#123;                redisTemplate.delete(key[0]);            &#125; else &#123;                redisTemplate.delete(Arrays.asList(key));            &#125;        &#125;    &#125;    // ============================String=============================    /**     * 普通缓存获取     * @param key 键     * @return 值     */    public Object get(String key) &#123;        return key == null ? null : redisTemplate.opsForValue().get(key);    &#125;    /**     * 普通缓存放入     * @param key 键     * @param value 值     * @return true成功 false失败     */    public boolean set(String key, Object value) &#123;        try &#123;            redisTemplate.opsForValue().set(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 普通缓存放入并设置时间     * @param key 键     * @param value 值     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期     * @return true成功 false 失败     */    public boolean set(String key, Object value, long time) &#123;        try &#123;            if (time &gt; 0) &#123;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);            &#125; else &#123;                set(key, value);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 递增     * @param key 键     * @param delta 要增加几(大于0)     */    public long incr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递增因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    /**     * 递减     * @param key 键     * @param delta 要减少几(小于0)     */    public long decr(String key, long delta) &#123;        if (delta &lt; 0) &#123;            throw new RuntimeException(&quot;递减因子必须大于0&quot;);        &#125;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    // ================================Map=================================    /**     * HashGet     * @param key 键 不能为null     * @param item 项 不能为null     */    public Object hget(String key, String item) &#123;        return redisTemplate.opsForHash().get(key, item);    &#125;    /**     * 获取hashKey对应的所有键值     * @param key 键     * @return 对应的多个键值     */    public Map&lt;Object, Object&gt; hmget(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    /**     * HashSet     * @param key 键     * @param map 对应多个键值     */    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * HashSet 并设置时间     * @param key 键     * @param map 对应多个键值     * @param time 时间(秒)     * @return true成功 false失败     */    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;        try &#123;            redisTemplate.opsForHash().putAll(key, map);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     * @param key 键     * @param item 项     * @param value 值     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 向一张hash表中放入数据,如果不存在将创建     * @param key 键     * @param item 项     * @param value 值     * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有效果     * @return true 成功 false失败     */    public boolean hset(String key, String item, Object value, long time) &#123;        try &#123;            redisTemplate.opsForHash().put(key, item, value);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 删除hash表中的值     * @param key 键 不能为null     * @param item 项 可以使多个 不能为null     */    public void hdel(String key, Object... item) &#123;        redisTemplate.opsForHash().delete(key, item);    &#125;    /**     * 判断hash表中是否有该项的值     * @param key 键 不能为null     * @param item 项 不能为null     * @return true 存在 false不存在     */    public boolean hHasKey(String key, String item) &#123;        return redisTemplate.opsForHash().hasKey(key, item);    &#125;    // ============================set=============================    /**     * 根据key获取Set中的所有值     * @param key 键     */    public Set&lt;Object&gt; sGet(String key) &#123;        try &#123;            return redisTemplate.opsForSet().members(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 根据value从一个set中查询,是否存在     * @param key 键     * @param value 值     * @return true 存在 false不存在     */    public boolean sHasKey(String key, Object value) &#123;        try &#123;            return redisTemplate.opsForSet().isMember(key, value);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将数据放入set缓存     * @param key 键     * @param values 值 可以是多个     * @return 成功个数     */    public long sSet(String key, Object... values) &#123;        try &#123;            return redisTemplate.opsForSet().add(key, values);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 将set数据放入缓存     * @param key 键     * @param time 时间(秒)     * @param values 值 可以是多个     * @return 成功个数     */    public long sSetAndTime(String key, long time, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().add(key, values);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return count;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 获取set缓存的长度     * @param key 键     */    public long sGetSetSize(String key) &#123;        try &#123;            return redisTemplate.opsForSet().size(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 移除值为value的     * @param key 键     * @param values 值 可以是多个     * @return 移除的个数     */    public long setRemove(String key, Object... values) &#123;        try &#123;            Long count = redisTemplate.opsForSet().remove(key, values);            return count;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    // ===============================list=================================    /**     * 获取list缓存的内容     * @param key 键     * @param start 开始     * @param end 结束 0 到 -1代表所有值     */    public List&lt;Object&gt; lGet(String key, long start, long end) &#123;        try &#123;            return redisTemplate.opsForList().range(key, start, end);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 获取list缓存的长度     * @param key 键     */    public long lGetListSize(String key) &#123;        try &#123;            return redisTemplate.opsForList().size(key);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;    /**     * 通过索引 获取list中的值     * @param key 键     * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推     */    public Object lGetIndex(String key, long index) &#123;        try &#123;            return redisTemplate.opsForList().index(key, index);        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;    /**     * 将list放入缓存     * @param key 键     * @param value 值     */    public boolean lSet(String key, Object value) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     * @param key 键     * @param value 值     * @param time 时间(秒)     */    public boolean lSet(String key, Object value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPush(key, value);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     * @param key 键     * @param value 值     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 将list放入缓存     * @param key 键     * @param value 值     * @param time 时间(秒)     * @return     */    public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123;        try &#123;            redisTemplate.opsForList().rightPushAll(key, value);            if (time &gt; 0) &#123;                expire(key, time);            &#125;            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 根据索引修改list中的某条数据     * @param key 键     * @param index 索引     * @param value 值     */    public boolean lUpdateIndex(String key, long index, Object value) &#123;        try &#123;            redisTemplate.opsForList().set(key, index, value);            return true;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;    /**     * 移除N个值为value     * @param key 键     * @param count 移除多少个     * @param value 值     * @return 移除的个数     */    public long lRemove(String key, long count, Object value) &#123;        try &#123;            Long remove = redisTemplate.opsForList().remove(key, count, value);            return remove;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return 0;        &#125;    &#125;&#125;\r\n使用方式\r\n@Overridepublic String login(String name, String password) &#123;    User user = userMapper.selectByName(name);    if (user != null) &#123;        if (PasswordEncryptUtil.verifyPassword(password, user.getPassword())) &#123;                        //通过id生成token            String token = jwtUtil.generateTokenById(user.getId());            // token存入名字叫tokenkey的地方3600秒            String tokenKey = &quot;user:token:&quot; + user.getId();            redisUtil.set(tokenKey, token, 3600);            //通过token得到id            Long userIdFromToken = jwtUtil.getUserIdFromToken(token);            System.out.println(&quot;token解析出的ID: &quot; + userIdFromToken);            return token;        &#125;    &#125;    // 登录失败    return &quot;登录失败&quot;;&#125;\r\n注意事项\r\n一般token是在header的地方传递，而不是body，所以如果需要接收token建议加一个参数HttpServletRequest,\r\n通过getHeader(\"token\")方法得到token然后解析回id比较好。\r\n基础依赖和配置\r\n下面给出SpringBoot最基础的依赖，无论上面的你用不用都需要默认添加的\r\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;\r\n下面是基础的配置\r\n# ===================== 应用基本配置 =====================# 应用名称spring.application.name=应用名称# ===================== 服务器配置 =====================# 服务运行端口server.port=8080# 应用访问根路径（默认/，无需修改）server.servlet.context-path=/# tomcat的URI编码（防止中文乱码）server.tomcat.uri-encoding=UTF-8# ===================== 数据库连接配置 =====================# mysql驱动类（8.x版本）spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver# 数据库连接地址，指定库、关闭SSL、设置时区、编码spring.datasource.url=jdbc:mysql://localhost:3306/数据库名字?useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8# 数据库用户名spring.datasource.username=root# 数据库密码spring.datasource.password=123456# Hikari连接池配置# 连接池最大连接数spring.datasource.hikari.maximum-pool-size=10# 连接池最小空闲连接数spring.datasource.hikari.minimum-idle=5# 连接超时时间（毫秒）spring.datasource.hikari.connection-timeout=30000# 连接空闲超时时间（毫秒）spring.datasource.hikari.idle-timeout=600000# 连接最大生命周期（毫秒）spring.datasource.hikari.max-lifetime=1800000                 \r\n可选配置\r\n# ===================== 日志配置 =====================# 自定义包下的日志级别（debug级，打印详细日志）logging.level.com.example=debug# spring security安全框架日志级别（debug级，排查权限问题）logging.level.org.springframework.security=debug# redis操作日志级别（debug级，排查redis交互问题）logging.level.org.springframework.data.redis=debug# 日志输出格式# 控制台日志输出格式logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n# 日志文件输出格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n# 日志文件存储路径/名称（项目根目录下的logs文件夹，文件名为auth-demo.log）logging.file.name=logs/auth-demo.log\r\n","categories":["后端"],"tags":["SpringBoot通用工具"]},{"title":"hello-world","url":"//posts/7424326681839718400.html","content":"Welcome to Hexo! This is your very\r\nfirst post. Check documentation for\r\nmore info. If you get any problems when using Hexo, you can find the\r\nanswer in troubleshooting or\r\nyou can ask me on GitHub.\r\nQuick Start\r\nCreate a new post\r\n$ hexo new &quot;My New Post&quot;\r\nMore info: Writing\r\nRun server\r\n$ hexo server\r\nMore info: Server\r\nGenerate static files\r\n$ hexo generate\r\nMore info: Generating\r\nDeploy to remote sites\r\n$ hexo deploy\r\nMore info: Deployment\r\n","categories":["测试"]},{"title":"手动创建后端项目","url":"//posts/270768891047936.html","content":"手动创建后端项目\r\n由于idea的版本不同等原因，导致在idea里面自动创建项目的方式不太相同，于是这里使用一个up主(程序员老罗)的手动创建后端项目的方式来进行，这样可以更好的定制化，因为东西的变化主要是dependency里面的玩意不同罢了\r\n具体步骤\r\n第一步 - 初始目录树\r\n新建一个文件夹作为你的后端项目的根目录。\r\n假如我们需要一个学生管理系统，那么将它取名为studentManager-java\r\n此时的目录树为\r\n- studentManager-java    - src        - main            - java            - resources    - pom.xml\r\n注意以上文件均为自己创建\r\n第二步 - 全局配置\r\n去idea设置项目\r\n\r\n\r\n\r\n第三步 - 完善目录树\r\n继续增加目录树\r\n- studentManager-java    - src        - main            - java            - resources                - application.properties    - pom.xml\r\n第四步 - 增加依赖\r\n导入你的项目的依赖到pom.xml里面,\r\n导入之后使用maven进行依赖的下载，下面给出一些常见的依赖\r\n// 项目基本信息&lt;groupId&gt;com.studentManager-java&lt;/groupId&gt;&lt;artifactId&gt;studentManager-java&lt;/artifactId&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;//springboot设置&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.6.1&lt;/version&gt;&lt;/parent&gt;//Web框架&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;//数据校验(用于@Valid @NotNull等注解)&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt;//数据库&lt;!-- Redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- MyBatis-Plus --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 代码生成器（按需添加） --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;$&#123;mybatis-generator.version&#125;&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;!-- 只在生成代码时使用 --&gt;&lt;/dependency&gt;&lt;!-- Freemarker 模板引擎 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;    &lt;version&gt;2.3.31&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- MySQL驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;8.0.23&lt;/version&gt;&lt;/dependency&gt;//网络通信netty -- 高并发要求大&lt;dependency&gt;    &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;    &lt;artifactId&gt;okhttp&lt;/artifactId&gt;    &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;//网络通信WebSocket -- 完整但是大&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;&lt;/dependency&gt;//网络通信javaWebSocket -- 小型项目&lt;dependency&gt;    &lt;groupId&gt;org.java-websocket&lt;/groupId&gt;    &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt;    &lt;version&gt;1.5.2&lt;/version&gt;&lt;/dependency&gt;//json处理&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.66&lt;/version&gt;&lt;/dependency&gt;//字符串日期工具&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&lt;/dependency&gt;//加密解密，base64编码解码&lt;dependency&gt;    &lt;groupId&gt;commons-codec&lt;/groupId&gt;    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;&lt;/dependency&gt;//文件IO&lt;dependency&gt;    &lt;groupId&gt;commons-io&lt;/groupId&gt;    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;&lt;/dependency&gt;//Redis锁&lt;dependency&gt;    &lt;groupId&gt;org.redisson&lt;/groupId&gt;    &lt;artifactId&gt;redisson&lt;/artifactId&gt;    &lt;version&gt;3.12.3&lt;/version&gt;&lt;/dependency&gt;//网络通信&lt;dependency&gt;    &lt;groupId&gt;io.netty&lt;/groupId&gt;    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;    &lt;version&gt;4.1.50.Final&lt;/version&gt;&lt;/dependency&gt;//图形验证码生成&lt;dependency&gt;    &lt;groupId&gt;com.github.whvcse&lt;/groupId&gt;    &lt;artifactId&gt;easy-captcha&lt;/artifactId&gt;&lt;/dependency&gt;//AOP切面&lt;dependency&gt;    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;&lt;/dependency&gt;//日志相关&lt;dependency&gt;    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;    &lt;version&gt;1.2.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 数据持久层：Spring Data JPA --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 密码安全核心 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 测试 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;//maven插件&lt;plugin&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;configuration&gt;        &lt;mainClass&gt;com.easychat.EasyChatApplication&lt;/mainClass&gt;    &lt;/configuration&gt;&lt;/plugin&gt;\r\n第五步 - 项目配置\r\n往application.properties里面写项目相关的配置信息，比如mysql的信息，redis的信息之类的，下面同样给出一些我个人的一些配置\r\n//项目自定义设置project.folder=d:/webser/studentManager-java/  # 项目文件存储路径log.root.level=debug                # 日志级别为DEBUGadmin.emails=fufu@163.com           # 管理员邮箱dev=false                           # 非开发环境//web服务器设置server.port=5050                     # HTTP服务端口server.servlet.context-path=/api     # 应用上下文路径，所有接口都以/api开头server.servlet.session.timeout=PT60M # Session超时时间60分钟//Websocket设置ws.port=5051                         # WebSocket服务端口//Mysql设置(注意url)spring.datasource.url=jdbc:mysql://127.0.0.1:3306/studentmanager-java?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=truespring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver//Redis设置spring.redis.host=127.0.0.1  # Redis服务器地址spring.redis.port=6379       # Redis端口spring.redis.database=0      # 使用0号数据库spring.redis.timeout=2000ms  # 连接超时2秒spring.redis.jedis.pool.max-active=20  # 最大连接数spring.redis.jedis.pool.max-idle=10    # 最大空闲连接//异常处理设置spring.mvc.throw-exception-if-no-handler-found=true  # 找不到处理器时抛出异常spring.web.resources.add-mappings=false              # 禁用静态资源映射//文件上传设置spring.servlet.multipart.max-file-size=15MB       # 单个文件最大15MBspring.servlet.multipart.max-request-size=15MB    # 单个请求最大15MB//hikari连接池设置spring.datasource.hikari.pool-name=HikariCPDatasourcespring.datasource.hikari.minimum-idle=5        # 最小空闲连接spring.datasource.hikari.maximum-pool-size=10  # 最大连接数spring.datasource.hikari.connection-timeout=30000  # 连接超时30秒//jpa设置spring.jpa.hibernate.ddl-auto=updatespring.jpa.show-sql=truespring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialectspring.jpa.properties.hibernate.format_sql=true\r\n第六步 - 数据库配置\r\n新建一个新的数据库\r\n名字：studentmanager-java字符集: utf8mb4排序规则: utf8mb4_0900_ai_ci\r\n第七步 - 创建启动类\r\n现在你可以去java下面创建软件包，目录树参考如下\r\n- studentManager-java    - src        - main            - java                - com                    - studentmanager-java                        - StudentManager-javaApplication.java            - resources                - application.properties    - pom.xml\r\n其中启动类配置如下\r\npackage com.studentmanager-java;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class StudentManager-javaApplication &#123;    public static void main(String[] args) &#123;        StudentManager-javaApplication.run(StudentManager-javaApplication.class, args);    &#125;&#125;\r\n选做\r\n下面是选做环节，如果你需要自己搞日志，那么你需要在第四步的地方添加(//日志相关)这个依赖，然后新建文件，下面是目录树\r\n- studentManager-java    - src        - main            - java            - resources                - application.properties                - logback-spring.xml    - pom.xml\r\n然后完善logback-spring.xml\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;10 minutes&quot;&gt;    &lt;appender name=&quot;stdot&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss,GMT+8&#125; [%p][%c][%M][%L]-&gt; %m%n&lt;/pattern&gt;        &lt;/layout&gt;    &lt;/appender&gt;    &lt;springProperty scope=&quot;context&quot; name=&quot;log.path&quot; source=&quot;project.folder&quot;/&gt;    &lt;springProperty scope=&quot;context&quot; name=&quot;log.root.level&quot; source=&quot;log.root.level&quot;/&gt;    &lt;property name=&quot;LOG_FOLDER&quot; value=&quot;logs&quot;/&gt;    &lt;property name=&quot;LOG_FILE_NAME&quot; value=&quot;easychat.log&quot;/&gt;    &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;file&gt;$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;&lt;/file&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;FileNamePattern&gt;$&#123;log.path&#125;/$&#123;LOG_FOLDER&#125;/$&#123;LOG_FILE_NAME&#125;.%d&#123;yyyyMMdd&#125;.%i&lt;/FileNamePattern&gt;            &lt;cleanHistoryOnStart&gt;true&lt;/cleanHistoryOnStart&gt;            &lt;TimeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;MaxFileSize&gt;20MB&lt;/MaxFileSize&gt;            &lt;/TimeBasedFileNamingAndTriggeringPolicy&gt;            &lt;maxHistory&gt;30&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;encoder&gt;            &lt;charset&gt;utf-8&lt;/charset&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss,GMT+8&#125; [%p][%c][%M][%L]-&gt; %m%n&lt;/pattern&gt;        &lt;/encoder&gt;        &lt;append&gt;false&lt;/append&gt;        &lt;prudent&gt;false&lt;/prudent&gt;    &lt;/appender&gt;    &lt;logger name=&quot;org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener&quot;            level=&quot;error&quot;&gt;&lt;/logger&gt;    &lt;logger name=&quot;org.redisson.connection.DNSMonitor&quot; level=&quot;error&quot;&gt;&lt;/logger&gt;    &lt;logger name=&quot;com.zaxxer.hikari&quot; level=&quot;info&quot;&gt;&lt;/logger&gt;    &lt;logger name=&quot;io.lettuce.core&quot; level=&quot;info&quot;&gt;&lt;/logger&gt;    &lt;logger name=&quot;org.springframework.data.redis&quot; level=&quot;info&quot;&gt;&lt;/logger&gt;    &lt;root level=&quot;$&#123;log.root.level&#125;&quot;&gt;        &lt;appender-ref ref=&quot;stdot&quot;/&gt;        &lt;appender-ref ref=&quot;file&quot;/&gt;    &lt;/root&gt;&lt;/configuration&gt;\r\n添加日志以后可以更好的看哪里出问题了，不然看控制台有点难看出来哪里错了，强烈推荐\r\n结束\r\n这样配置项就完成了可以开始开发你的项目了\r\n偷懒可以全部复制粘贴上去，不会真的有人一个一个记吧\r\n","categories":["后端"]},{"title":"测试文章3","url":"//posts/7424326681839718402.html","content":"这是一篇测试文章\r\n今天我的博客算是成功搭建完成了，下面这篇文章是我的功能测试文章，主要来测试是否有实现代码高亮，latex数学语法和图片等相关内容\r\n代码高亮\r\n下面是一个非常经典的C程序\r\n#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int N = 300010;int dp[N];void solve() &#123;    cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; &#x27;\\n&#x27;;&#125;signed main()&#123;    int T = 1;    //cin &gt;&gt; T;    while(T -- ) &#123;        solve();    &#125;        return 0;&#125;\r\n数学表达式\r\n下面测试数学表达式\r\n加法： a + b\r\n减法：c − d\r\n乘法：a × b\r\n除法：$\\frac{a}{b}$ 或 a ÷ b\r\n分数：$\\frac{numerator}{denominator}$ 上下标：x2 和 xi\r\n图片测试\r\n\r\n\r\n其它测试\r\n你好 这是粗体字 这是斜体字\r\n这是删除字\r\n`你好`  **这是粗体字** *这是斜体字* ~~这是删除字~~\r\n\r\n\r\n\r\na\r\nb\r\nc\r\n\r\n\r\n\r\n\r\naa\r\nbb\r\ncc\r\n\r\n\r\naaa\r\nbbb\r\nccc\r\n\r\n\r\naaaa\r\nbbbb\r\ncccc\r\n\r\n\r\n\r\nMermaid流程图测试\r\ngraph TD    A[开始学习] --&gt; B&#123;选择科目&#125;    B --&gt;|数学| C[学习公式]    B --&gt;|编程| D[编写代码]    C --&gt; E[完成练习]    D --&gt; F[调试程序]    E --&gt; G[掌握技能]    F --&gt; G    G --&gt; H[🎉 成功!]\r\nsequenceDiagram    participant 用户    participant 浏览器    participant 服务器    participant 数据库        用户-&gt;&gt;浏览器: 输入网址    浏览器-&gt;&gt;服务器: 发送HTTP请求    服务器-&gt;&gt;数据库: 查询数据    数据库--&gt;&gt;服务器: 返回数据    服务器--&gt;&gt;浏览器: 返回HTML页面    浏览器--&gt;&gt;用户: 显示网页内容\r\nclassDiagram    class 动物 &#123;        +String 名称        +int 年龄        +eat()        +sleep()    &#125;        class 狗 &#123;        +String 品种        +bark()        +fetch()    &#125;        class 猫 &#123;        +boolean 是否家养        +meow()        +scratch()    &#125;        动物 &lt;|-- 狗    动物 &lt;|-- 猫\r\npie    title 每日时间分配    &quot;工作&quot; : 8    &quot;学习&quot; : 3    &quot;娱乐&quot; : 2    &quot;运动&quot; : 1    &quot;睡眠&quot; : 8    &quot;其他&quot; : 2\r\n","categories":["测试"]},{"title":"测试文章4","url":"//posts/7424326681839718403.html","content":"这是一个图片 \r\n\r\n\r\n测试\r\n\r\n","categories":["测试"]},{"title":"代码高亮测试","url":"//posts/7424326681839718401.html","content":"macOS 代码高亮测试\r\n测试1：JavaScript 代码\r\n// macOS风格JavaScript测试class Person &#123;  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;    sayHello() &#123;    console.log(`Hello, $&#123;this.name&#125;!`);    return `I&#x27;m $&#123;this.age&#125; years old.`;  &#125;&#125;const person = new Person(&quot;Alice&quot;, 25);person.sayHello();// 箭头函数const multiply = (a, b) =&gt; a * b;// Promise示例fetch(&#x27;/api/data&#x27;)  .then(response =&gt; response.json())  .then(data =&gt; console.log(data))  .catch(error =&gt; console.error(error));\r\n测试2：Python 代码\r\n# macOS风格Python测试def fibonacci(n):    &quot;&quot;&quot;计算斐波那契数列&quot;&quot;&quot;    if n &lt;= 1:        return n    return fibonacci(n-1) + fibonacci(n-2)class Animal:    def __init__(self, name, species):        self.name = name        self.species = species        def speak(self):        if self.species == &quot;dog&quot;:            return &quot;Woof!&quot;        elif self.species == &quot;cat&quot;:            return &quot;Meow!&quot;        else:            return &quot;Hello!&quot;# 列表推导式squares = [x**2 for x in range(10)]# 使用f-stringanimal = Animal(&quot;Buddy&quot;, &quot;dog&quot;)print(f&quot;&#123;animal.name&#125; says: &#123;animal.speak()&#125;&quot;)\r\n测试3：HTML + CSS 代码\r\n&lt;!-- macOS风格HTML测试 --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;测试页面&lt;/title&gt;    &lt;style&gt;        /* macOS风格CSS测试 */        .container &#123;            width: 100%;            max-width: 1200px;            margin: 0 auto;            padding: 20px;        &#125;                .card &#123;            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);            border-radius: 15px;            padding: 30px;            color: white;            box-shadow: 0 10px 30px rgba(0,0,0,0.2);        &#125;                .btn &#123;            background-color: #007aff; /* macOS蓝色 */            color: white;            padding: 10px 20px;            border-radius: 8px;            border: none;            cursor: pointer;            font-size: 16px;        &#125;                @media (max-width: 768px) &#123;            .container &#123;                padding: 10px;            &#125;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;container&quot;&gt;        &lt;div class=&quot;card&quot;&gt;            &lt;h1&gt;Hello macOS Style!&lt;/h1&gt;            &lt;button class=&quot;btn&quot;&gt;点击按钮&lt;/button&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\r\n测试4：Bash/Shell 命令\r\n#!/bin/bash# macOS风格Shell脚本测试echo &quot;开始部署Hexo博客...&quot;# 清理缓存hexo clean# 生成静态文件hexo generate# 启动本地服务器echo &quot;启动本地服务器...&quot;hexo server --port 4000# 检查端口占用PORT=4000if lsof -Pi :$PORT -sTCP:LISTEN -t &gt;/dev/null ; then    echo &quot;✅ 服务器正在运行: http://localhost:$PORT&quot;else    echo &quot;❌ 服务器启动失败&quot;    exit 1fi# Git操作示例git add .git commit -m &quot;更新代码高亮测试&quot;git push origin main\r\n测试5：JSON 数据\r\n&#123;  &quot;blog&quot;: &#123;    &quot;name&quot;: &quot;我的技术博客&quot;,    &quot;url&quot;: &quot;https://example.com&quot;,    &quot;author&quot;: &#123;      &quot;name&quot;: &quot;开发者&quot;,      &quot;email&quot;: &quot;dev@example.com&quot;    &#125;,    &quot;config&quot;: &#123;      &quot;theme&quot;: &quot;butterfly&quot;,      &quot;highlight_theme&quot;: &quot;mac&quot;,      &quot;font_family&quot;: &quot;SF Pro Display, -apple-system&quot;    &#125;  &#125;,  &quot;posts&quot;: [    &#123;      &quot;title&quot;: &quot;Hexo配置指南&quot;,      &quot;date&quot;: &quot;2024-01-01&quot;,      &quot;tags&quot;: [&quot;Hexo&quot;, &quot;博客&quot;, &quot;教程&quot;]    &#125;,    &#123;      &quot;title&quot;: &quot;JavaScript高级技巧&quot;,      &quot;date&quot;: &quot;2024-01-02&quot;,      &quot;tags&quot;: [&quot;JavaScript&quot;, &quot;前端&quot;]    &#125;  ]&#125;\r\n测试6：无语言标注（自动检测）\r\n# 这个块没有指定语言，测试auto_detectfunction testAutoDetect() &#123;  let x = 10;  const y = 20;  return x + y;&#125;print(&quot;Hello World&quot;);\r\n\r\n检查点： 1. 代码块是否有红黄绿灯按钮？ 🚥 2.\r\n语法颜色是否美观？ 3. 是否有行号？ 4. 右上角是否显示语言类型？ 5.\r\n是否有复制按钮？\r\n保存文件后访问：http://localhost:4000/代码高亮测试/\r\n","categories":["测试"]},{"title":"自动更新修改日期","url":"//posts/270874779328512.html","content":"自动更新修改日期\r\n在平时我们对数据库进行更新或者插入的时候，创建时间和更新时间一直是绕不开的话题，对于每个类都最好加上创建时间和更新时间，这样在面对排序或者时间比较的时候可以很好的处理，但如果每次我们更新的时候都要自己set一下会很麻烦麻烦在需要多打两行这一块，所以为了减少代码压力，可以使用MyBatisPlus里面的MetaObjectHandler来进行自动填充，通过实现该接口并重写方法，可在插入或更新操作时，自动为指定字段赋值，从而减少重复代码，提升开发效率。\r\n准备工作\r\n添加MyBatisPlus依赖\r\n&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.5.6&lt;/version&gt; &lt;!-- 与Spring Boot 2.6.1兼容 --&gt;&lt;/dependency&gt;\r\n添加自动填充处理器\r\npackage com.userdemo.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.time.LocalDateTime;@Component  // 必须添加，让Spring管理public class MyMetaObjectHandler implements MetaObjectHandler &#123;        /**     * 插入时自动填充     */    @Override    public void insertFill(MetaObject metaObject) &#123;        // 获取当前时间        LocalDateTime now = LocalDateTime.now();                // 填充创建时间（字段名需与实体类一致）        this.strictInsertFill(metaObject, &quot;createTime&quot;, LocalDateTime.class, now);                // 填充更新时间（插入时也设置）        this.strictInsertFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, now);                // 可选：如果还有其他审计字段，如创建人        // this.strictInsertFill(metaObject, &quot;createBy&quot;, String.class, &quot;system&quot;);    &#125;        /**     * 更新时自动填充     */    @Override    public void updateFill(MetaObject metaObject) &#123;        // 只填充更新时间        this.strictUpdateFill(metaObject, &quot;updateTime&quot;, LocalDateTime.class, LocalDateTime.now());                // 可选：更新人        // this.strictUpdateFill(metaObject, &quot;updateBy&quot;, String.class, &quot;admin&quot;);    &#125;&#125;\r\n修改你需要自动填充的类，在里面的创建时间和修改时间上面添加注解\r\npackage com.userdemo.entity.po;import com.baomidou.mybatisplus.annotation.*;import lombok.Data;import java.time.LocalDateTime;@Data@TableName(&quot;user&quot;)  // 指定表名public class User &#123;        @TableId(type = IdType.AUTO)  // 主键自增    private Long id;        private String username;    private String password;        // 创建时间：只在插入时填充    @TableField(fill = FieldFill.INSERT)    @Column(name = &quot;createtime&quot;)    private LocalDateTime createTime;        // 更新时间：插入和更新时都填充    @TableField(fill = FieldFill.INSERT_UPDATE)    @Column(name = &quot;updatetime&quot;)    private LocalDateTime updateTime;    &#125;\r\n一些问题\r\n\r\nMyMetaObjectHandler类是否有@Component注解\r\n实体类字段是否有@TableField(fill = ...)注解\r\n字段名是否一致（createTime vs\r\ncreate_time）\r\n是否使用了MyBatis-Plus的方法（save(),\r\nupdateById()）\r\n\r\n做完上述步骤以后，时间便不再需要你手动的更新了，节约了你的时间\r\n","categories":["后端"],"tags":["MyBatisPlus"]},{"title":"用户密码加密","url":"//posts/270816817389568.html","content":"用户密码加密\r\n在进行项目制作时，如果只是一般的练手项目，那么用户密码可以不设置加密，也就是前端收到用户名和密码以后传给后端，后端不进行密码的加密直接放入数据库。\r\n但是如果该项目需要应用了，那么这个方法是很危险的，因为密码没有加密，导致别人如果想爬你的后端将直接获得所有未加密的密码，为此后端需要对密码进行加密后存储到数据库，前端依旧传密码给后端，但后端需要将密码加密后匹配数据库中的加密，而传统的md5类型加密方式如今已经不安全了，为此需要新的加密方式，这里我采用的是encrypt加密方式，下面是一个登录注册的demo来熟悉。\r\n构建项目\r\n项目的目录树如下\r\n- userdemo    - src        - main            - java            - resources                - application.properties    - pom.xml\r\npom.xml依赖如下\r\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.userdemo&lt;/groupId&gt;    &lt;artifactId&gt;userdemo&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.1&lt;/version&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- Web基础 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- 数据持久层：Spring Data JPA --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- 数据库 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 参数验证 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- Spring Security加密模块 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;            &lt;artifactId&gt;spring-security-crypto&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- JSON处理（已有，保留） --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;            &lt;version&gt;1.2.66&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 测试 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;!-- 这里需要修改为你实际的主启动类 --&gt;                    &lt;mainClass&gt;com.userdemo.UserDemoApplication&lt;/mainClass&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\r\n配置如下\r\nserver.port=5050server.servlet.context-path=/apiserver.servlet.session.timeout=60mspring.datasource.url=jdbc:mysql://127.0.0.1:3306/userdemo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=truespring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.jpa.hibernate.ddl-auto=nonespring.jpa.show-sql=truespring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialectspring.jpa.properties.hibernate.format_sql=true\r\n对于我的后端项目，我习惯于使用up主程序员老罗的那一套返回类，为此这个地方的配置你可以跟着我也可以自己写\r\n返回类配置\r\n我建立的目录树如下：\r\n- userdemo    - src        - main            - java                - com.userdemo                    - controller                        - ABaseController                    - entity                        - enums                            - ResponseCodeEnum.enum                        - vo                            - ResponseVO.java                    - exception                        - BusinessException.java            - resources                - application.properties    - pom.xml\r\nABaseController\r\npackage com.userdemo.controller;import com.userdemo.entity.enums.ResponseCodeEnum;import com.userdemo.entity.vo.ResponseVO;import com.userdemo.exception.BusinessException;public class ABaseController &#123;    protected static final String STATUC_SUCCESS = &quot;success&quot;;    protected static final String STATUC_ERROR = &quot;error&quot;;    protected &lt;T&gt; ResponseVO getSuccessResponseVO(T t) &#123;        ResponseVO&lt;T&gt; responseVO = new ResponseVO&lt;&gt;();        responseVO.setStatus(STATUC_SUCCESS);        responseVO.setCode(ResponseCodeEnum.CODE_200.getCode());        responseVO.setInfo(ResponseCodeEnum.CODE_200.getMsg());        responseVO.setData(t);        return responseVO;    &#125;    protected &lt;T&gt; ResponseVO getBusinessErrorResponseVO(BusinessException e, T t) &#123;        ResponseVO vo = new ResponseVO();        vo.setStatus(STATUC_ERROR);        if (e.getCode() == null) &#123;            vo.setCode(ResponseCodeEnum.CODE_600.getCode());        &#125; else &#123;            vo.setCode(e.getCode());        &#125;        vo.setInfo(e.getMessage());        vo.setData(t);        return vo;    &#125;    protected &lt;T&gt; ResponseVO getServerErrorResponseVO(T t) &#123;        ResponseVO vo = new ResponseVO();        vo.setStatus(STATUC_ERROR);        vo.setCode(ResponseCodeEnum.CODE_500.getCode());        vo.setInfo(ResponseCodeEnum.CODE_500.getMsg());        vo.setData(t);        return vo;    &#125;&#125;\r\nResponseCodeEnum\r\npackage com.userdemo.entity.enums;public enum ResponseCodeEnum &#123;    CODE_200(200, &quot;请求成功&quot;),    CODE_404(404, &quot;请求地址不存在&quot;),    CODE_600(600, &quot;请求参数错误&quot;),    CODE_601(601, &quot;信息已经存在&quot;),    CODE_901(901, &quot;登录超时&quot;),    CODE_500(500, &quot;服务器返回错误，请联系管理员&quot;);    private Integer code;    private String msg;    ResponseCodeEnum(Integer code, String msg) &#123;        this.code = code;        this.msg = msg;    &#125;    public Integer getCode() &#123;        return code;    &#125;    public String getMsg() &#123;        return msg;    &#125;&#125;\r\nResponseVO\r\npackage com.userdemo.entity.vo;public class ResponseVO&lt;T&gt; &#123;    private String status;    private Integer code;    private String info;    private T data;    public String getStatus() &#123;        return status;    &#125;    public void setStatus(String status) &#123;        this.status = status;    &#125;    public Integer getCode() &#123;        return code;    &#125;    public void setCode(Integer code) &#123;        this.code = code;    &#125;    public T getData() &#123;        return data;    &#125;    public void setData(T data) &#123;        this.data = data;    &#125;    public String getInfo() &#123;        return info;    &#125;    public void setInfo(String info) &#123;        this.info = info;    &#125;&#125;\r\nBusinessException\r\npackage com.userdemo.exception;import com.userdemo.entity.enums.ResponseCodeEnum;public class BusinessException extends RuntimeException &#123;    private ResponseCodeEnum codeEnum;    private Integer code;    private String message;    public BusinessException(String message, Throwable e) &#123;        super(message, e);        this.message = message;    &#125;    public BusinessException(String message) &#123;        super(message);        this.message = message;    &#125;    public BusinessException(Throwable e) &#123;        super(e);    &#125;    public BusinessException(ResponseCodeEnum codeEnum) &#123;        super(codeEnum.getMsg());        this.codeEnum = codeEnum;        this.code = codeEnum.getCode();        this.message = codeEnum.getMsg();    &#125;    public BusinessException(Integer code, String message) &#123;        super(message);        this.code = code;        this.message = message;    &#125;    public ResponseCodeEnum getCodeEnum() &#123;        return codeEnum;    &#125;    public Integer getCode() &#123;        return code;    &#125;    @Override    public String getMessage() &#123;        return message;    &#125;    /**     * 重写fillInStackTrace 业务异常不需要堆栈信息，提高效率.目的是为了看到错误而不是看哪行抛出，抛出位置不一定是错误位置     */    @Override    public Throwable fillInStackTrace() &#123;        return this;    &#125;&#125;\r\n正式开始\r\n首先我们去数据库建立一个user表，里面至少包含如下内容：\r\n- id (自增id)- name- password (加密后的密码)- createtime- updatetime\r\n在xml里面引入这个依赖，其实一开始上面有\r\n&lt;!-- Spring Security加密模块 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;    &lt;artifactId&gt;spring-security-crypto&lt;/artifactId&gt;&lt;/dependency&gt;\r\n然后写一个工具类，用来密码的加密，注意这种加密方式对于同一个密码的多次加密的哈希值几乎不可能相同，不同密码也几乎不可能生成同一种哈希值，该加密方法无法反解，但是可以匹配加密前后的密码是否一致，添加下面这个工具类：PasswordEncryptUtil.java\r\npackage com.userdemo.util;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Component;@Componentpublic class PasswordEncryptUtil &#123;        private static final PasswordEncoder passwordEncoder = new BCryptPasswordEncoder();    /**     * 加密密码     * @param rawPassword 明文密码     * @return 加密后的密码     */    public static String encryptPassword(String rawPassword) &#123;        if (rawPassword == null) &#123;            throw new IllegalArgumentException(&quot;密码不能为null&quot;);        &#125;        return passwordEncoder.encode(rawPassword);    &#125;    /**     * 验证密码     * @param rawPassword 明文密码     * @param encodedPassword 加密后的密码     * @return 验证结果     */    public static boolean verifyPassword(String rawPassword, String encodedPassword) &#123;        if (rawPassword == null || encodedPassword == null) &#123;            return false;        &#125;        return passwordEncoder.matches(rawPassword, encodedPassword);    &#125;        /**     * 检查编码后的密码是否需要重新编码（例如，由于算法强度变化）     * @param encodedPassword 已编码的密码     * @return 是否需要重新编码     */    public static boolean isPasswordRehashNeeded(String encodedPassword) &#123;        return passwordEncoder.upgradeEncoding(encodedPassword);    &#125;&#125;\r\n简单测试\r\npackage com.userdemo.example;import com.userdemo.util.PasswordEncryptUtil;public class BcryptTest &#123;    public static void main(String[] args) &#123;        String password = &quot;1234567890&quot;;                // 多次加密同一个密码        String hash1 = PasswordEncryptUtil.encryptPassword(password);        String hash2 = PasswordEncryptUtil.encryptPassword(password);        String hash3 = PasswordEncryptUtil.encryptPassword(password);                System.out.println(&quot;原始密码: &quot; + password);        System.out.println(&quot;第一次加密: &quot; + hash1);        System.out.println(&quot;第二次加密: &quot; + hash2);        System.out.println(&quot;第三次加密: &quot; + hash3);                // 验证每个哈希值是否都能与原密码匹配        System.out.println(&quot;\\n验证结果:&quot;);        System.out.println(&quot;Hash1 与原密码匹配: &quot; + PasswordEncryptUtil.verifyPassword(password, hash1));        System.out.println(&quot;Hash2 与原密码匹配: &quot; + PasswordEncryptUtil.verifyPassword(password, hash2));        System.out.println(&quot;Hash3 与原密码匹配: &quot; + PasswordEncryptUtil.verifyPassword(password, hash3));                // 验证不同哈希值之间是否相同（预期应该是不同的）        System.out.println(&quot;\\n哈希值是否相同:&quot;);        System.out.println(&quot;Hash1 和 Hash2 相同: &quot; + hash1.equals(hash2));        System.out.println(&quot;Hash1 和 Hash3 相同: &quot; + hash1.equals(hash3));        System.out.println(&quot;Hash2 和 Hash3 相同: &quot; + hash2.equals(hash3));                // 验证错误密码是否能匹配        System.out.println(&quot;\\n错误密码验证:&quot;);        System.out.println(&quot;错误密码与Hash1匹配: &quot; + PasswordEncryptUtil.verifyPassword(&quot;wrongpassword&quot;, hash1));    &#125;&#125;\r\n你会发现是可以成功验证的\r\n加入数据库\r\n我的项目结构如下\r\nsrc/└── main/    ├── java/    │   └── com.userdemo/    │       ├── controller/    │       │   ├── ABaseController - 返回配置    │       │   └── UserController - 注册登录控制类    │       ├── entity/    │       │   ├── enums/    │       │   │   └── ResponseCodeEnum - 返回配置    │       │   ├── po/    │       │   │   └── User - 实体类    │       │   └── vo/    │       │       └── ResponseVO - 返回配置    │       ├── example/    │       ├── exception/    │       │   └── BusinessException - 返回配置    │       ├── repository/    │       │   └── UserRepository - jpa存数据库方法    │       ├── util/    │       │   └── PasswordEncryptUtil - 加密工具    │       └── UserDemoApplication    └── resources/        └── application.properties\r\n下面给出剩下的一些配置，添加以后使用postman工具即可进行测试了，你会发现数据库可以拿到数据，同时数据是加密后的\r\nUserController\r\n@RestController@RequestMapping(&quot;/users&quot;)public class UserController extends ABaseController &#123;        @Autowired    private PasswordEncryptUtil encryptUtil;    @Autowired    private UserRepository userRepository;    /**     * 登录     */    @PostMapping(&quot;/login&quot;)    public ResponseVO login(String email, String password) &#123;        User user = userRepository.findByEmail(email);        if(user == null) return getSuccessResponseVO(&quot;用户不存在，登录失败&quot;);        if(encryptUtil.verifyPassword(password, user.getPassword())) return getSuccessResponseVO(&quot;登录成功&quot;);        return getSuccessResponseVO(&quot;登录失败&quot;);    &#125;    /**     * 注册     */    @PostMapping(&quot;/register&quot;)    public ResponseVO register(String email, String password) &#123;        if(password.isEmpty()) return getSuccessResponseVO(&quot;密码为空，注册失败&quot;);        String newPassword = encryptUtil.encryptPassword(password);        User user = new User();        user.setName(email);        user.setEmail(email);        user.setPassword(newPassword);        user.setCreateTime(LocalDateTime.now());        user.setUpdateTime(LocalDateTime.now());        userRepository.save(user);        return getSuccessResponseVO(&quot;注册成功&quot;);    &#125;&#125;\r\nuser\r\n@Entity@Table(name = &quot;user&quot;)public class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    @Column(nullable = false, unique = true)    private String name;    @Column(nullable = false)    private String password;    @Column    private String email;    @Column(name = &quot;createtime&quot;)    private LocalDateTime createTime;    @Column(name = &quot;updatetime&quot;)    private LocalDateTime updateTime;    // Getter和Setter方法&#125;\r\nUserRepository\r\n@Repositorypublic interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;    // 根据邮箱查找用户    User findByEmail(String email);&#125;\r\n","categories":["后端"]},{"title":"雪花算法生成id","url":"//posts/270550459478016.html","content":"雪花算法生成id\r\n在项目制作的时候，生成id是一个问题，如果是一个小项目可以考虑使用数据库自己的唯一key按照顺序生成id，但如果同一时间有很多人点击注册，那么可能会产生id冲突的问题，为了解决这个问题，有人发明了雪花算法来生成唯一id号，目前雪花算法来生成的id重复概率极低，因此也广泛运用于各种项目之中，下面展示了c++和java的两种雪花id生成代码\r\n其实我的博客的后面一大串神秘数字.html也是通过雪花生成的，因为自己懒\r\nc++代码\r\n#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;cstdint&gt;using namespace std;/** * 极简版雪花算法 - 单文件可运行版本 */class SimpleIdGenerator &#123;private:    static constexpr uint64_t START_EPOCH = 1704067200000ULL; // 2024-01-01 00:00:00        uint64_t lastTime = 0;    uint64_t sequence = 0;    mutex mtx;        uint64_t getCurrentTime() &#123;        auto now = chrono::system_clock::now();        return chrono::duration_cast&lt;chrono::milliseconds&gt;(            now.time_since_epoch()).count();    &#125;    public:    // 生成唯一ID    uint64_t generate() &#123;        lock_guard&lt;mutex&gt; lock(mtx);                uint64_t currentTime = getCurrentTime();                if (currentTime &lt; lastTime) &#123;            // 时钟回拨，增加序列号            sequence = (sequence + 1) &amp; 0xFFF;            currentTime = lastTime;        &#125;                if (currentTime == lastTime) &#123;            sequence = (sequence + 1) &amp; 0xFFF;            if (sequence == 0) &#123;                // 序列号溢出，等待下一毫秒                while (currentTime &lt;= lastTime) &#123;                    currentTime = getCurrentTime();                &#125;            &#125;        &#125; else &#123;            sequence = 0;        &#125;                lastTime = currentTime;                // 组合ID：时间戳(41位) + 序列号(12位)        return ((currentTime - START_EPOCH) &lt;&lt; 12) | sequence;    &#125;&#125;;\r\n使用方法 int main() &#123;    cout &lt;&lt; &quot;=== 雪花算法ID生成器演示 ===&quot; &lt;&lt; endl;        // 创建生成器    SimpleIdGenerator generator;        // 生成10个ID    cout &lt;&lt; &quot;\\n生成10个唯一ID:&quot; &lt;&lt; endl;    for (int i = 0; i &lt; 10; i++) &#123;        uint64_t id = generator.generate();        cout &lt;&lt; &quot;ID &quot; &lt;&lt; (i+1) &lt;&lt; &quot;: &quot; &lt;&lt; id &lt;&lt; endl;    &#125;        // 测试连续生成    cout &lt;&lt; &quot;\\n连续生成5个ID:&quot; &lt;&lt; endl;    for (int i = 0; i &lt; 5; i++) &#123;        cout &lt;&lt; generator.generate() &lt;&lt; endl;    &#125;        return 0;&#125;\r\njava版本\r\nimport java.util.concurrent.atomic.AtomicLong;/** * 极简雪花算法ID生成器 * 复制这个类即可使用 */public class SnowflakeIdGenerator &#123;        // 开始时间戳 (2024-01-01)    private static final long START_TIMESTAMP = 1704067200000L;        // 上次生成ID的时间戳    private static long lastTimestamp = -1L;        // 序列号    private static long sequence = 0L;        // 序列号位数    private static final long SEQUENCE_BITS = 12L;        // 序列号最大值    private static final long MAX_SEQUENCE = ~(-1L &lt;&lt; SEQUENCE_BITS);        // 锁对象    private static final Object lock = new Object();        /**     * 生成唯一ID     */    public static long nextId() &#123;        synchronized (lock) &#123;            long timestamp = System.currentTimeMillis();                        // 时钟回拨处理            if (timestamp &lt; lastTimestamp) &#123;                throw new RuntimeException(&quot;时钟回拨异常&quot;);            &#125;                        // 同一毫秒内生成            if (lastTimestamp == timestamp) &#123;                sequence = (sequence + 1) &amp; MAX_SEQUENCE;                if (sequence == 0) &#123;                    // 序列号用完，等待下一毫秒                    timestamp = tilNextMillis(lastTimestamp);                &#125;            &#125; else &#123;                sequence = 0L;            &#125;                        lastTimestamp = timestamp;                        // 组合ID            return ((timestamp - START_TIMESTAMP) &lt;&lt; SEQUENCE_BITS) | sequence;        &#125;    &#125;        /**     * 生成字符串ID     */    public static String nextIdStr() &#123;        return String.valueOf(nextId());    &#125;        /**     * 阻塞到下一毫秒     */    private static long tilNextMillis(long lastTimestamp) &#123;        long timestamp = System.currentTimeMillis();        while (timestamp &lt;= lastTimestamp) &#123;            timestamp = System.currentTimeMillis();        &#125;        return timestamp;    &#125;        /**     * 使用示例     */    public static void main(String[] args) &#123;        System.out.println(&quot;=== 雪花ID生成测试 ===&quot;);                // 生成10个ID        for (int i = 0; i &lt; 10; i++) &#123;            long id = SnowflakeIdGenerator.nextId();            System.out.println(&quot;ID &quot; + (i + 1) + &quot;: &quot; + id);        &#125;                // 生成字符串ID        System.out.println(&quot;\\n字符串ID: &quot; + SnowflakeIdGenerator.nextIdStr());    &#125;&#125;\r\n","categories":["后端"],"tags":["算法"]},{"title":"键盘说明书-RKr98","url":"//posts/7424402798374211584.html","content":"RKr98键盘说明书\r\n由于我的键盘在运输过程中总是会按到发光键，但是我其实不喜欢发光键，所以在这里将键盘的说明书展示出来，便于我到时候出问题了可以直接看\r\n常用的按键\r\n锁windows键 -Fn + Win关闭所有灯光 -Fn + Esc...\r\nrkr98说明书\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","categories":["数码"],"tags":["数码"]},{"title":"全局拦截器","url":"//posts/272299195691008.html","content":"全局拦截器\r\n前端返回给后端token之后，后端一般需要去redis或者你自己的验证方式通过token得到对应的id，确认用户信息以后再返回给前端，但是这段路如果每个controller都这么写会多代码量节约时间这一块,\r\n所以为了节约时间，同时防止不需要token的链接也被全局拦截器拦截，我还需要对不需要token的链接进行排除，下面是一些细节，一些东西是根据我之前的那篇文章，Springboot通用工具合集里面的，这里不再赘述。\r\n没有拦截前\r\n下面给出一个经典场景，前端通过请求头给出了token，假如是这样的\r\nAuthorization: AAA123456 or token: AAA123456\r\ncontroller得到对应token以后进行解析，然后对数据库进行操作，最后返回结果给前端\r\n@RequestMapping(&quot;/info&quot;)    public ResponseVO info(HttpServletRequest request) &#123;        String token = request.getHeader(&quot;Authorization&quot;);        Long userId = jwtUtil.getUserIdFromToken(token);        User user = userMapper.selectById(userId);        // 统一返回类可以成功拦截所有异常，不会将异常结果返回给前端，只会返回统一的错误信息        if(user == null) &#123;            return getBusinessErrorResponseVO(new BusinessException(&quot;用户不存在&quot;), null);        &#125;        // 封装用户信息，返回给前端        UserInfoVO userInfoVO = new UserInfoVO();        userInfoVO.setId(user.getId())                .setUsername(user.getUsername())                .setNickname(user.getNickname())                .setAvatar(user.getAvatar())                .setStatus(user.getStatus())                .setContent(user.getContent())                .setUpdateTime(user.getUpdateTime());        return getSuccessResponseVO(userInfoVO);    &#125;\r\n看上去也没有很多，确实，这里只需要判断user是否为空就好了，但实际上我们还要判断token是否合法，id是否合法这些，为此我们的拦截器就有用了，可以对需要请求头的数据进行拦截来判断\r\npackage com.wsdemo.interceptor;import com.wsdemo.entity.CurrentLoginUser;import com.wsdemo.entity.enums.ClientStatusEnum;import com.wsdemo.entity.po.User;import com.wsdemo.exception.BusinessException;import com.wsdemo.mapper.UserMapper;import com.wsdemo.util.JwtUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 全局拦截器 校验token是否合法 */@Slf4j@Componentpublic class AuthInterceptor extends HandlerInterceptorAdapter &#123;    @Resource    private JwtUtil jwtUtil;    @Resource    private UserMapper userMapper;    /**     * 重写拦截器     */    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123;        log.info(&quot;======================进入拦截器了!!!!==========================&quot;);        log.info(request.getRequestURI());        String token = request.getHeader(&quot;Authorization&quot;);        log.info(&quot;======================token!!!==========================&quot;);        log.info(token);        if(token == null) &#123;            log.info(&quot;token为空, 请重新登录&quot;);            throw new BusinessException(&quot;token为空, 请重新登录&quot;);        &#125;        Long id = jwtUtil.getUserIdFromToken(token);        if (id == null) &#123;            log.info(&quot;id找不到, 请重新登录&quot;);            throw new BusinessException(&quot;id找不到, 请重新登录&quot;);        &#125;        // 创建当前登录用户对象, 返回内容回去        CurrentLoginUser loginUser = new CurrentLoginUser();        User user = userMapper.selectById(id);        loginUser.setId(user.getId())                .setUsername(user.getUsername())                .setNickname(user.getNickname())                .setAvatar(user.getAvatar())                .setStatus(user.getStatus())                .setToken(token)                .setClientStatus(ClientStatusEnum.APP);        // 将当前登录用户信息缓存到request里面，方便以后使用        request.setAttribute(&quot;CURRENT_USER&quot;, loginUser);        return true;    &#125;&#125;\r\n同时还需要配置类AppConfig\r\n这里是让你把你不需要请求头的东西全部放行掉\r\npackage com.wsdemo.config;import com.wsdemo.interceptor.AuthInterceptor;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import javax.annotation.Resource;/** * 自定义配置 */@Configurationpublic class AppConfig extends WebMvcConfigurationSupport &#123;    @Resource    private AuthInterceptor authInterceptor;    /**     * 添加拦截器     * @param registry     */    @Override    protected void addInterceptors(InterceptorRegistry registry) &#123;        // 必须先调用父类方法        super.addInterceptors(registry);                // 添加拦截器(不需要加api前缀，默认了)和确认哪些不需要拦截器        registry.addInterceptor(authInterceptor)                .addPathPatterns(&quot;/**&quot;)                .excludePathPatterns(&quot;/user/code&quot;)                .excludePathPatterns(&quot;/user/login&quot;)                .excludePathPatterns(&quot;/user/registry&quot;)                .excludePathPatterns(&quot;/error&quot;)           // 错误处理                .excludePathPatterns(&quot;/uploads/**&quot;)      // 上传文件                .excludePathPatterns(&quot;/doc.html&quot;)                .excludePathPatterns(&quot;/swagger-ui/**&quot;)                .excludePathPatterns(&quot;/swagger-resources&quot;)                .excludePathPatterns(&quot;/v2/api-docs&quot;)                .excludePathPatterns(&quot;/webjars/**&quot;)                .order(1);    &#125;&#125;\r\n为此一个常见的拦截器就做完了\r\n拦截之后\r\n注意现在从CURRENT_USER字段(这个字段你可以自己设置，在前面的AuthInterceptor里面)直接获取对应的返回值就可以了，我这里是一个登录类，得到id再来查询得到user，最后返回相关信息回去\r\n@RequestMapping(&quot;/info&quot;)    public ResponseVO info(HttpServletRequest request) &#123;                CurrentLoginUser loginUser = (CurrentLoginUser) request.getAttribute(&quot;CURRENT_USER&quot;);        Long userId = loginUser.getId();        User user = userMapper.selectById(userId);        // 统一返回类可以成功拦截所有异常，不会将异常结果返回给前端，只会返回统一的错误信息        if(user == null) &#123;            return getBusinessErrorResponseVO(new BusinessException(&quot;用户不存在&quot;), null);        &#125;        // 验证用户状态        if(user.getStatus() != UserStatusEnum.DEFAULT) &#123;            return getBusinessErrorResponseVO(new BusinessException(&quot;用户状态异常&quot;), null);        &#125;        // 封装用户信息，返回给前端        UserInfoVO userInfoVO = new UserInfoVO();        userInfoVO.setId(user.getId())                .setUsername(user.getUsername())                .setNickname(user.getNickname())                .setAvatar(user.getAvatar())                .setStatus(user.getStatus())                .setContent(user.getContent())                .setUpdateTime(user.getUpdateTime());        return getSuccessResponseVO(userInfoVO);    &#125;\r\n总结\r\n目录树如下\r\n- config    - AppConfig- interceptor    - AutoInterceptor\r\n之后的程序不用每次都去查数据库，直接看token就知道是谁在访问(拦截器已经帮你查完了，你只需要用就完事)\r\n","categories":["后端"]}]